/* --*-c++-*-- */
/**
 * Godzi
 * Copyright 2010 Pelican Mapping
 * http://pelicanmapping.com
 * http://github.com/gwaldron/godzi
 *
 * Godzi is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef GODZI_FEATURES_GEOMETRY
#define GODZI_FEATURES_GEOMETRY 1

#include <Godzi/Common>
#include <osg/Object>
#include <osgEarthSymbology/Geometry>

namespace Godzi { namespace Features {

        class GODZI_EXPORT Geometry : public osg::Object
        {
        public:
            enum Type {
                TYPE_UNKNOWN,
                TYPE_POINT,
                TYPE_LINESTRING,
                TYPE_LINEARRING,
                TYPE_POLYGON,
                TYPE_MULTIGEOMETRY,
                TYPE_MODEL
            };

            static std::string toString( Type t ) {
                return 
                    t == TYPE_POINT ? "point" :
                    t == TYPE_LINESTRING ? "linestring" :
                    t == TYPE_LINEARRING ? "linearring" :
                    t == TYPE_POLYGON ? "polygon" :
                    t == TYPE_MULTIGEOMETRY ? "multigeometry" :
                    t == TYPE_MODEL ? "model" :
                    "unknown";
            }

            static Geometry* create( Type type, const osg::Vec3dArray* toCopy );

            /**
             * Creates a new Vec3Array (single-precision), copies the part into it, and
             * returns the new object. 
             */
            virtual osg::Vec3Array* toVec3Array() const = 0;
            virtual Type getType() const = 0;
            virtual osg::Vec3dArray* getCoordinates() = 0;
            virtual const osg::Vec3dArray* getCoordinates() const = 0;
        };
        typedef std::vector<osg::ref_ptr<Geometry> > GeometryList;


        class Point : public Geometry
        {
        public:
            META_Object(Godzi, Point);
            Point(const Point& pm, const osg::CopyOp& cp = osg::CopyOp::DEEP_COPY_ALL);
            Point();
            Point( const osg::Vec3dArray* point );

            virtual Type getType() const { return TYPE_POINT;}
            osg::Vec3Array* toVec3Array() const;
            osg::Vec3dArray* getCoordinates();
            const osg::Vec3dArray* getCoordinates() const;

            /** Specifies how altitude components in the <coordinates> element are interpreted. Possible values are
                clampToGround - (default) Indicates to ignore an altitude specification (for example, in the <coordinates> tag).
                relativeToGround - Sets the altitude of the element relative to the actual ground elevation of a particular location. For example, if the ground elevation of a location is exactly at sea level and the altitude for a point is set to 9 meters, then the elevation for the icon of a point placemark elevation is 9 meters with this mode. However, if the same coordinate is set over a location where the ground elevation is 10 meters above sea level, then the elevation of the coordinate is 19 meters. A typical use of this mode is for placing telephone poles or a ski lift.
                absolute - Sets the altitude of the coordinate relative to sea level, regardless of the actual elevation of the terrain beneath the element. For example, if you set the altitude of a coordinate to 10 meters with an absolute altitude mode, the icon of a point placemark will appear to be at ground level if the terrain beneath is also 10 meters above sea level. If the terrain is 3 meters above sea level, the placemark will appear elevated above the terrain by 7 meters. A typical use of this mode is for aircraft placement.
            */
            enum AltitudeMode {
                ClampToGround, 
                RelativeToGround,
                Absolute,
                RelativeToSeaFloor,
                ClampToSeaFloor, 
            };

            void setAltitudeMode(const AltitudeMode& altitude) { _altitudeMode = altitude; }
            AltitudeMode getAltitudeMode() const { return _altitudeMode; }

            void setExtrude(bool extrude) { _extrude = extrude;}
            bool getExtrude() const { return _extrude; }

        protected:
            osg::ref_ptr<osgEarth::Symbology::PointSet> _geom;

            //Boolean value. Specifies whether to connect the point to the ground with a line. To extrude a Point, the value for <altitudeMode> must be either relativeToGround, relativeToSeaFloor, or absolute. The point is extruded toward the center of the Earth's sphere
            bool _extrude;
            AltitudeMode _altitudeMode;
        };


        class LineString : public Geometry
        {
        public:
            META_Object(Godzi, LineString);
            LineString(const LineString& pm, const osg::CopyOp& cp = osg::CopyOp::DEEP_COPY_ALL);
            LineString();
            LineString( const osg::Vec3dArray* point );

            virtual Type getType() const { return TYPE_LINESTRING;}
            osg::Vec3Array* toVec3Array() const;
            osg::Vec3dArray* getCoordinates();
            const osg::Vec3dArray* getCoordinates() const;

        protected:
            osg::ref_ptr<osgEarth::Symbology::LineString> _geom;

        };

        class LinearRing : public Geometry
        {
        public:
            META_Object(Godzi, LinearRing);
            LinearRing(const LinearRing& pm, const osg::CopyOp& cp = osg::CopyOp::DEEP_COPY_ALL);
            LinearRing();
            LinearRing( const osg::Vec3dArray* point );

            virtual Type getType() const { return TYPE_LINEARRING;}
            osg::Vec3Array* toVec3Array() const;
            osg::Vec3dArray* getCoordinates();
            const osg::Vec3dArray* getCoordinates() const;

        protected:
            osg::ref_ptr<osgEarth::Symbology::Ring> _geom;

        };

        typedef std::vector<osg::ref_ptr<LinearRing> > LinearRingList;

        class Polygon : public Geometry
        {
        public:
            META_Object(Godzi, Polygon);
            Polygon(const Polygon& pm, const osg::CopyOp& cp = osg::CopyOp::DEEP_COPY_ALL);
            Polygon();
            Polygon( const osg::Vec3dArray* point );

            virtual Type getType() const { return TYPE_POLYGON;}
            osg::Vec3Array* toVec3Array() const;
            osg::Vec3dArray* getCoordinates();
            const osg::Vec3dArray* getCoordinates() const;
            LinearRingList& getHoles() { return _holes; }
            const LinearRingList& getHoles() const { return _holes; }

        protected:
            osg::ref_ptr<LinearRing> _outer;
            LinearRingList _holes;

        };


        class MultiGeometry : public Geometry
        {
        public:
            META_Object(Godzi, MultiGeometry);
            MultiGeometry(const MultiGeometry& pm, const osg::CopyOp& cp = osg::CopyOp::DEEP_COPY_ALL);
            MultiGeometry();
            virtual Type getType() const { return TYPE_MULTIGEOMETRY;}

            const GeometryList& getGeometryList() const;
            GeometryList& getGeometryList();

            osg::Vec3Array* toVec3Array() const { return 0; }
            osg::Vec3dArray* getCoordinates() { return 0; }
            const osg::Vec3dArray* getCoordinates() const { return 0; }

        protected:
            GeometryList _geometryList;

        };


}}

#endif
