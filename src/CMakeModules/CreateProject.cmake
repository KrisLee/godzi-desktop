# Macro to setup a project; contains common setup routines to be used with create_library and create_executable
# Usage: create_project(PROJECTNAME [PARENTPROJECT <project-name>]
#                       [SUBDIRECTORIES <dir-name> [<dir-name> [...]]]
#                       [DEPENDENCIES [<project-name> [<project-name> [...]]] [INTERNAL <project-name>] ... ]
#                       [LIBDEPENDENCIES [<library-name> [<library-name> [...]]] [INTERNAL <library-name>] ... ]
#                       [INCLUDE_PATH [<include-path> [<include-path> [...]]] [INTERNAL <include-path>] ... ]
#                       [DEFINITIONS [<definition> [<definition> [...]]] [INTERNAL <definition>] ... ]
#                       [LIBRARY_PATH [<library-path> [<library-path> [...]]] [INTERNAL <library-path>] ... ]
#                       [LIBRARIES [<library> [<library> [...]]] [INTERNAL <library>] ... ])
#
# Exports include path, definition, library path, and libary variables to be used with projects/targets which depend on the new project.  
# The variables are named as ${PROJECTNAME}_INCLUDE_PATH, ${PROJECTNAME}_DEFINITIONS, ${PROJECTNAME}_LIBRARY_PATH, and ${PROJECTNAME}_LIBRARIES, 
# where ${PROJECTNAME} represents the value specified for the macro's NAME argument.  Arguments prefixed with the INTERNAL modifier will be
# excluded from the exported variables.  Also creates the internal and external scoped dependency lists generated by the create_dependency_lists macro.  
#
# Only the PROJECTNAME parameter is required.  All other parameters are optional.  
# PROJECTNAME defines the name with which the project will be referenced.  The CMake 'project' command is invoked with this name
# creating the ${PROJECTNAME}_SOURCE_PATH and ${PROJECTNAME}_BINARY_PATH variables.  See the documentation for 'project' for
# more information.  
#
# The PARENTPROJECT specifies that a subproject of an existing project is to be defined.  The parent project's external and internal 
# variables will be merged with the subproject's variables.  This is different than normal project dependencies which only merge the 
# external variables.  Only one parent project is allowed.  
#
# The SUBDIRECTORIES paramter specifies a list of names for subdirectories containing CMakeLists.txt files to included with the project.  
#
# The DEPENDENCIES parameter specifies a list of names for dependency targets on which the new project depends.  The names are the values
# specified for the DEPENDENCYNAME parameter when the dependecies were created.  Include paths, definitions, library paths, and libraries
# associated with each dependency will automatically be added for the current project.  Values from projects not marked INTERNAL will also be exported 
# as part of the include paths, definitions, library paths, and libraries variables defined for the new project.  
#
# The LIBDEPENDENCIES parameter is like the DEPENDENCIES parameter for library targets created with the create_library macro 
# instead of projects created by the create_project macro.  The <library-name> value is included as a link dependency of the project.  
#
# INCLUDE_PATH, DEFINITIONS, LIBRARY_PATH, and LIBRARIES define the dependencies for the project which are not included by any
# of the projects specified with the DEPENDENCIES parameter.  This could include system or external third-party dependencies.  
# Values not marked INTERNAL will be added to the exported variables defined for the new project.  

macro(create_project PROJECTNAME)

    # Define the project
    project(${PROJECTNAME})

    # Argument list names
    set(arglists "PARENTPROJECT;SUBDIRECTORIES;DEPENDENCIES;LIBDEPENDENCIES;INCLUDE_PATH;DEFINITIONS;LIBRARY_PATH;LIBRARIES")

    # Get the argument lists
    parse_arguments(ARG "${arglists}" "" ${ARGN})

    # Create the dependency lists.  Instead of juut specifying ${ARGN}, separate lists so the ordering of list specification does not matter (basically extracting the SUBDIRECTORIES list)
    create_dependency_lists(${PROJECTNAME}
                            ${${PROJECTNAME}_SOURCE_DIR}
                            DEPENDENCIES ${ARG_DEPENDENCIES}
                            LIBDEPENDENCIES ${ARG_LIBDEPENDENCIES}
                            INCLUDE_PATH ${ARG_INCLUDE_PATH}
                            DEFINITIONS ${ARG_DEFINITIONS}
                            LIBRARY_PATH ${ARG_LIBRARY_PATH}
                            LIBRARIES ${ARG_LIBRARIES})

    # Merge the parent's internal and external values
    if(ARG_PARENTPROJECT)
        unique_append(${PROJECTNAME}_INTERNAL_LIBDEPENDENCIES ${${ARG_PARENTPROJECT}_INTERNAL_LIBDEPENDENCIES})
        unique_append(${PROJECTNAME}_INTERNAL_INCLUDE_PATH ${${ARG_PARENTPROJECT}_INTERNAL_INCLUDE_PATH})
        unique_append(${PROJECTNAME}_INTERNAL_DEFINITIONS ${${ARG_PARENTPROJECT}_INTERNAL_DEFINITIONS})
        unique_append(${PROJECTNAME}_INTERNAL_LIBRARY_PATH ${${ARG_PARENTPROJECT}_INTERNAL_LIBRARY_PATH})
        unique_append(${PROJECTNAME}_INTERNAL_LIBRARIES ${${ARG_PARENTPROJECT}_INTERNAL_LIBRARIES})
        unique_append(${PROJECTNAME}_EXTERNAL_LIBDEPENDENCIES ${${ARG_PARENTPROJECT}_EXTERNAL_LIBDEPENDENCIES})
        unique_append(${PROJECTNAME}_EXTERNAL_INCLUDE_PATH ${${ARG_PARENTPROJECT}_EXTERNAL_INCLUDE_PATH})
        unique_append(${PROJECTNAME}_EXTERNAL_DEFINITIONS ${${ARG_PARENTPROJECT}_EXTERNAL_DEFINITIONS})
        unique_append(${PROJECTNAME}_EXTERNAL_LIBRARY_PATH ${${ARG_PARENTPROJECT}_EXTERNAL_LIBRARY_PATH})
        unique_append(${PROJECTNAME}_EXTERNAL_LIBRARIES ${${ARG_PARENTPROJECT}_EXTERNAL_LIBRARIES})
    endif(ARG_PARENTPROJECT)

    # Add the sub-directories
    foreach(value ${ARG_SUBDIRECTORIES})
        add_subdirectory(${value})
    endforeach(value ${ARG_SUBDIRECTORIES})
    
endmacro(create_project PROJECTNAME)
